/*
 File: validator.mjs
 Purpose: Validate line count and character limits using the central
 code-standards.config.json and provide utilities to validate single or
 multiple files against those rules. Keeps validation logic isolated for
 reuse by CI tasks and scripts.
 All Rights Reserved. Arodi Emmanuel
*/
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { getCharLimit } from '../limits/char-limits.mjs'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const cfgPath = path.resolve(__dirname, '../../../code-standards.config.json')
const cfg = JSON.parse(fs.readFileSync(cfgPath, 'utf8'))
const MAX_LINES = cfg.fileLineLimit

/**
 * Validate a single file
 * @param {string} filePath path to file
 * @returns {{valid:boolean, errors:string[]}}
 */
export function validateFile(filePath) {
  if (!fs.existsSync(filePath)) return { valid: true, errors: [] }
  
  // Skip JSON files (i18n locales, config files)
  if (path.extname(filePath).toLowerCase() === '.json') {
    return { valid: true, errors: [] }
  }
  
  // Skip auto-generated i18n key files
  // (path segment + AUTOGENERATED header marker)
  if (filePath.includes(path.join('src', 'shared', 'i18n', 'generated'))) {
    const content = fs.readFileSync(filePath, 'utf8')
    if (/AUTOGENERATED/i.test(content)) {
      return { valid: true, errors: [] }
    }
  }
  const lines = fs.readFileSync(filePath, 'utf8').split(/\r?\n/)
  const charLimit = getCharLimit(filePath)
  const errors = []

  if (lines.length > MAX_LINES) {
    errors.push(`Max-lines ${lines.length} in ${filePath}`)
  }

  lines.forEach((line, i) => {
    if (line.length > charLimit) {
      const lineNum = i + 1
      errors.push(
        `Max-chars ${line.length}/${charLimit} in ${filePath}:${lineNum}`
      )
    }
  })

  return { valid: errors.length === 0, errors }
}

/**
 * Validate multiple files
 * @param {string[]} filePaths paths to validate
 * @returns {{valid:boolean, errors:string[]}}
 */
export function validateFiles(filePaths) {
  const allErrors = []
  for (const p of filePaths) {
    const r = validateFile(p)
    allErrors.push(...r.errors)
  }
  return { valid: allErrors.length === 0, errors: allErrors }
}
