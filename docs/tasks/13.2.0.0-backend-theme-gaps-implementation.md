/\* File: 13.2.0.0-backend-theme-gaps-implementation.md

- Purpose: Actionable backlog to close backend gaps required by Task 13.2
  (Frontend Tailwind UI Library Config & Migration) before starting frontend
  implementation.
- All Rights Reserved. \*/

MARK STEPS AS COMPLETED AFTER SUCCESSFUL IMPLEMENTATION

# Task 13.2.0.0 Backend Theme & Tokens Gaps Implementation

Goal: Close the minimum backend functionality gaps so the frontend UI
token-driven theming system (Task 13.2) can start on a stable contract: stable
keys, dynamic current customization, caching (ETag), and complete root groups
(including `fontWeights`). Provide extensibility for later independent updates
of customization sets.

---

## Scope

This task delivers the minimal but production-aligned backend features needed by
the frontend token consumer:

- Stable theme keys (not DB ids) + persisted.
- Dynamic `current` selections reflecting active theme and future other choices.
- `fontWeights` group added to `/api/v1/tokens` payload.
- ETag + conditional GET for token bundle.
- Documentation of contract + caching semantics.
- Foundation abstractions to later persist non-theme groups and selection
  changes without breaking contract.

Out of scope (will be separate follow-ups): font binary proxying, per-user
selections, partial group fetch optimization, mutation endpoints.

---

## Current State Summary (Baseline)

- `/api/v1/tokens` returns themes (dynamic), other groups static, and a
  hardcoded `current`.
- Theme keys currently equal to database `id` (unstable across environments).
- No `fontWeights` group; others present.
- No ETag / 304 support.
- No domain model for selection; `current` provider hardcoded.

---

## Success Criteria

- Calling `GET /api/v1/tokens` returns 200 with structure:
  `themes, fonts, fontSizes, spacings, radius, shadows, fontWeights, current`.
- Each theme object has a stable semantic `key` (e.g. `default`, `dark`, etc.)
  independent of numeric id.
- `current.theme` matches the active theme's stable key (or documented fallback
  rule) – no hardcoded string.
- Response includes `ETag` header; same data fingerprint → identical ETag;
  `If-None-Match` with current value returns 304.
- New field `fontWeights: ["400","500","700"]` (numeric CSS weight tokens)
  included; frontend may map to semantic labels locally.
- Docs page updated describing payload shape, caching, evolution strategy, and
  notes on forthcoming per-theme spacing override model.

---

## Risks & Mitigation

| Risk                                     | Mitigation                                                           |
| ---------------------------------------- | -------------------------------------------------------------------- |
| Changing theme key later breaks frontend | Introduce now & migrate seeding before frontend consumes.            |
| ETag collisions or over-invalidation     | Fingerprint only semantic fields (keys, hashes, current selections). |
| Future per-user customization differs    | Encapsulate selection resolution behind a resolver component.        |
| Seeder migration complexity              | Provide one-off backfill logic if existing themes already persisted. |

---

## Step-by-Step Implementation Plan

### Phase 1: Stable Theme Keys [DONE]

1. Add `key` field to domain `Theme` aggregate (validation: lowercase kebab,
   2–40 chars, unique) and persistence (`ThemeEntity` new column `theme_key`
   with unique index).
2. Extend `ThemeValidator` to validate `key` (new parameter) – refactor
   constructors/builders.
3. Update seeder constants: change format to `key|name|colorKey=value,...` OR
   introduce parallel array mapping existing names to keys. Prefer explicit new
   format for clarity.
4. Migration/backfill strategy:
   - If existing rows lack `theme_key`, derive from
     `LOWER(REPLACE(name, ' ', '-'))`; ensure uniqueness by appending `-n` if
     collision.
   - Document this in inline comment + task file.
5. Update `UITokensThemesDynamicProvider` to map `dto.key = theme.getKey()`
   instead of id.
6. Add repository query adaptation if required (search by key future use case
   placeholder). Avoid exposing by id in tokens.

### Phase 2: Current Selection Resolution [DONE]

1. Create domain model `UiCustomizationSelection` (value object) with fields:
   `themeKey, fontKey, fontSizeKey, spacingKey, radiusKey, shadowKey`.
2. Define ports:
   - Query: `CustomizationSelectionQueryPort` with
     `Optional<UiCustomizationSelection> getSystemSelection()`.
   - Command: `CustomizationSelectionCommandPort` with
     `UiCustomizationSelection save(UiCustomizationSelection)` (future).
3. Provide in-memory adapter implementation for now
   (`InMemoryCustomizationSelectionAdapter`), seeded with defaults resolved
   dynamically:
   - `themeKey` = active theme if exists else first theme stable key.
   - Others = first value of each group provider.
4. Refactor `UITokensCurrentProvider`:
   - Convert from static utility to `@Component`.
   - Inject `CustomizationSelectionQueryPort` + `GetActiveThemeUseCase` fallback
     path.
   - Build `current` from resolved selection.
5. Adjust `UITokensDataProvider` to inject new provider instead of static call.

### Phase 3: Font Weights Group (Decision Embedded) [DONE]

Decision: Represent font weights strictly as numeric CSS weight strings
(`"400"`, `"500"`, `"700"`) to keep backend contract minimal; frontend maps to
semantic labels (normal / medium / bold) via i18n.

1. Add `public List<String> fontWeights;` to `UITokensDto` (place after
   `fonts`).
2. Implement `UITokensFontWeightsProvider` returning
   `List.of("400","500","700")`.
3. Populate in `UITokensDataProvider` BEFORE fingerprint/ETag computation.
4. Update documentation + sample payload; note semantic mapping happens
   client-side only.

### Phase 4: ETag & Conditional GET [DONE]

1. Introduce a `TokensFingerprintBuilder` component that receives the assembled
   `UITokensDto` and extracts a canonical representation:
   - For each group: list of items with `key` and version/hash fields only (e.g.
     for fonts use `key + hash`, for themes use `key + colors hash`).
   - Include `current` selection keys concatenated.
2. Serialize canonical string (e.g. join with `|`) and compute SHA-256 hex.
3. Modify controller:
   - Accept `@RequestHeader(value = "If-None-Match", required = false)`.
   - If match → return 304 with `ETag` header.
   - Else → return 200 + body + `ETag` header.
4. Add unit test for stable ETag (unchanged data → same value) and mismatch when
   a theme is modified.

### Phase 5: Documentation [DONE]

1. Create/Update `docs/domains/ui-tokens.md` (or if existing, append) with:
   - Payload schema (groups, current, fontWeights addition).
   - Caching sequence diagram (Client → GET with/without ETag → 200/304).
   - Evolution rules (additive fields only in v1; breaking → v2 path).
   - Selection resolution rules (active theme precedence, fallback ordering).
2. Reference from original Task 13.2 file.

### Phase 6: Refactoring & Abstraction Prep (Future Per-Theme Overrides Ready) [DONE]

Includes preparation for future per-theme spacing overrides without breaking
existing contracts.

1. Wrap existing static providers (fonts, fontSizes, spacings, radius, shadows,
   fontWeights) behind simple interfaces (e.g. `FontsProviderPort`).
2. Adjust `UITokensDataProvider` to depend on those interfaces (constructor
   injection) for testability & future replacement.
3. Add design note in docs (not code TODO) describing extension path for
   per-theme spacing overrides:
   - Option A: Add optional `overrides.spacing` object to each theme payload
     (additive, only keys that differ).
   - Option B: Add theme-to-spacing-set association (theme references spacing
     set key) enabling composition & reuse.
   - Fingerprint logic must isolate theme override changes to the theme slice to
     minimize unnecessary ETag invalidation of unrelated groups.
4. Ensure fingerprint builder already modular (group-by-group) to absorb
   overrides later with minimal refactor.

### Phase 7: Testing [DONE]

1. Added tests (each under 80 lines; individual test classes under 40 lines when
   split logically):
   - `UITokensControllerConditionalGetTest`: verifies 200 then 304 with same
     ETag.
   - `UITokensCurrentSelectionTest`: active theme toggle changes `current.theme`
     and updates ETag and fingerprint.
   - `ThemeSeederKeysTest`: ensures seeding assigns expected stable keys.
   - `UITokensControllerEtagNormalizationTest`: explicit coverage for quoted vs
     unquoted `If-None-Match` header producing 304 (normalization logic).
2. Providers mocked or lightweight wired consistent with existing pattern; ports
   ensure isolation.
3. All assertions deterministic; no time or randomness dependencies.

### Phase 8: Quality & Compliance [DONE]

1. Verify all new files have header comment.
2. Ensure file length limits (<100 backend lines) — split large classes
   (builder, fingerprint logic) if necessary.
3. i18n keys for validation errors (extend `ThemeValidator` error keys if new
   ones added for key format).
4. Update `module-blueprint` references if any architectural deviation.

---

## Expected Result

`GET /api/v1/tokens` exposes stable, cacheable, semantically versioned token
bundle with dynamic current selection and complete groups required by Task 13.2
frontend token consumption.

## Actual Result (Progress Update 2025-09-03)

Completed Phases 1–4:

- Phase 1: Added stable `key` to `Theme` aggregate, persistence layer,
  validator, seeder format, and dynamic theme provider now emits semantic keys
  (no DB ids exposed).
- Phase 2: Introduced `UiCustomizationSelection` value object and refactored
  `UITokensCurrentProvider` into a Spring component resolving current selection
  dynamically (active theme fallback logic implemented). Data provider updated
  accordingly.
- Phase 3: Added `fontWeights` group (`["400","500","700"]`) to `UITokensDto`,
  provider, and population sequence.
- Phase 4: Implemented weak ETag support using new `TokensFingerprintBuilder`
  (SHA-256 over deterministic canonical form). Controller now returns `ETag` and
  supports `If-None-Match` → 304.

Completed Phases 5–8 (2025-09-03):

- Phase 5 Documentation [DONE]: `docs/domains/ui-tokens.md` updated (payload
  schema, caching semantics, evolution rules, selection logic, checklist all
  checked).
- Phase 6 Abstractions [DONE]: Provider interfaces (`ThemesProviderPort`,
  `FontsProviderPort`, `FontSizesProviderPort`, `SpacingsProviderPort`,
  `RadiusProviderPort`, `ShadowsProviderPort`, `FontWeightsProviderPort`)
  implemented; `UITokensDataProvider` depends only on ports.
- Phase 7 Testing [DONE]: Full planned coverage plus explicit quoted/unquoted
  ETag normalization (`UITokensControllerEtagNormalizationTest`). Stable key
  seeder test present as `ThemeSeederKeysTest` (name adjusted from initial
  draft). All tests green.
- Phase 8 Quality [DONE]: Headers present, line limits respected, i18n
  validation keys (`theme.key.invalid`, selection.\*) in use, fingerprint
  modular for future overrides.

Next Steps (Post Task – out of scope here): per-theme spacing override design
decision, user-level selection persistence, mutation endpoints.

Task 13.2.0.0 is now COMPLETE (all phases DONE; no remaining gaps).
